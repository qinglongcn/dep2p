package main

import (
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"os"
	"strings"

	mh "github.com/multiformats/go-multihash"
)

const bits = 16          // 每个前缀的位数为 16
const target = 1 << bits // 目标值是 2 的 bits 次方，即 2^16
const idLen = 32 + 2     // ID 的长度为 32 加上 2

// 此方法的用途是生成一个 Golang 包，其中包含一个名为 `keyPrefixMap` 的数组。该数组包含了一组前缀值，用于将哈希值映射到对应的索引位置。
// 这个程序根据一定的规则生成这些前缀值，并将它们存储在数组中，然后将生成的代码写入一个文件中。
// 生成的代码应该用于其他程序中，以便根据哈希值查找对应的索引位置。请注意，生成的代码应该由开发人员使用，并且不应该手动编辑。
func main() {
	pkg := os.Getenv("GOPACKAGE")                                   // 获取环境变量 GOPACKAGE 的值
	file := os.Getenv("GOFILE")                                     // 获取环境变量 GOFILE 的值
	targetFile := strings.TrimSuffix(file, ".go") + "_prefixmap.go" // 构建目标文件名

	ids := new([target]uint32) // 创建一个长度为 target 的 uint32 数组
	found := new([target]bool) // 创建一个长度为 target 的 bool 数组
	count := int32(0)          // 初始化计数器为 0

	out := make([]byte, 32)             // 创建一个长度为 32 的字节切片
	inp := [idLen]byte{mh.SHA2_256, 32} // 创建一个长度为 idLen 的字节数组，其中第一个字节为 mh.SHA2_256，后面 32 个字节为 32
	hasher := sha256.New()              // 创建一个 SHA256 哈希对象

	for i := uint32(0); count < target; i++ {
		binary.BigEndian.PutUint32(inp[2:], i) // 将 i 的值以大端字节序写入 inp 的第三个字节开始的位置

		hasher.Write(inp[:])      // 计算 inp 的哈希值
		out = hasher.Sum(out[:0]) // 将哈希结果存储到 out 中，并重置 out 的长度为 0
		hasher.Reset()            // 重置哈希对象

		prefix := binary.BigEndian.Uint32(out) >> (32 - bits) // 将 out 转换为大端字节序的 uint32，并右移 (32 - bits) 位，得到前缀值
		if !found[prefix] {                                   // 如果前缀值在 found 数组中不存在
			found[prefix] = true // 将前缀值标记为已找到
			ids[prefix] = i      // 将 i 存储到对应的前缀值位置
			count++              // 计数器加一
		}
	}

	f, err := os.Create(targetFile) // 创建目标文件
	if err != nil {
		panic(err)
	}

	printf := func(s string, args ...interface{}) {
		_, err = fmt.Fprintf(f, s, args...) // 将格式化的字符串写入文件
		if err != nil {
			panic(err)
		}
	}

	printf("package %s\n\n", pkg)                                         // 写入包名
	printf("// Code generated by generate/generate_map.go DO NOT EDIT\n") // 写入生成代码的注释
	printf("var keyPrefixMap = [...]uint32{")                             // 写入 keyPrefixMap 的定义开始部分
	for i, j := range ids[:] {
		if i%16 == 0 {
			printf("\n\t") // 每行输出 16 个元素
		} else {
			printf(" ") // 元素之间用空格分隔
		}
		printf("%d,", j) // 写入元素值
	}
	printf("\n}") // 写入 keyPrefixMap 的定义结束部分
	if err = f.Close(); err != nil {
		panic(err)
	}
}
